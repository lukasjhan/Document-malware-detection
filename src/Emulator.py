import sys

class Emulator:
    def __init__(self, program):
        self.mem = program
        self.instructions = [ "ret", "call", "pop", "push", "dec", "mov", "mul", "cmp", "jg", "int", "xor" ]
        self.registers = {"eax":0, "ebx":0, "ecx":0, "edx":0, "esp":0, "ebp":0 , "esi":0, "edi":0, "eip":0}
        self.stack = [0] * 40
        self.flags = { "l":True, "lt":True, "e":True, "ne":True, "g":True, "ge":True }

        self.breakmatch = []

        self.registers["esp"] = len( self.stack )-1

    def add_break_match(self, match):
        self.breakmatch.append(match)

    def check_break_match(self, data):
        return data in self.breakmatch

    def getStack(self):
        return self.stack
    
    def getRegs(self):
        return self.registers
    
    def step( self ):
        # execute the current line
        isJump = self.execute()

        if isJump:
            return

        line = self.lines[ self.ip ]
        self.ip = self.nextIp()

    def push( self, item, comment=None ):
        registers[ "esp" ] -= 1
        if comment==None:
            stack[ registers[ "esp" ] ] = item
        else:
            stack[ registers[ "esp" ] ] = \
                   "{0:1} {1:1}".format( item, comment )

    def pop( self ):
        item = stack[ registers[ "esp" ] ]
        if type( item )==type( "string" ):
            item = int( item.split()[0].strip() )
        registers[ "esp" ] += 1
        return item

        
    def execute( self ):

        instruction = fields[0]
        if len( fields )==3:
            operand1 = fields[1].replace( ',','' ).strip()
            operand2 = fields[2].replace( ',','' ).strip()
        if len( fields )==2:
            operand1 = fields[-1].replace( ',','' ).strip()
            operand2 = None
        if len( fields )==1:
            operand1 = None
            operand2 = None
            
        #int
        if instruction == "int" and operand1 =="0x80":
            print( "\n\nDone!\n\n" )
            sys.exit()

        # call label
        if instruction == "call":
            label = self.getDest( line )
            #print( "call to", label )
            self.push( self.nextIp(), "*" )
            self.ip = self.labelAddress[ label ]
            return True # is a jump

        # push
        if instruction == "push":
            if operand1 in registers.keys():
                self.push( registers[ operand1 ], stackComment )
            else:
                print( "*** Error: trying to push ", operand1 )
            return False

        # pop
        if instruction == "pop":
            if operand1 in registers.keys():
                data = self.pop()
                registers[ operand1 ] = data
            else:
                print( "*** Error: trying to pop into ", operand1 )
            return False

        # mov
        if instruction == "mov":
            #print( "mov: instr=", instruction, "op1=", operand1,
            #       "op2=", operand2 )
            if operand2 in registers.keys():                
                data = int( registers[operand2] )
            elif operand2.find( "ebp+" )!=-1:
                operand2 = operand2.replace( "]", "" )
                offset = int( operand2.split( "ebp+" )[1] )
                data = stack[ registers["ebp"] + offset//4 ]
                if type(data)==type("string"):
                    data = int( data.split()[0].strip() )
                #print( "mov operand2 = ", operand2, "offset = ", offset )
            else:
                data = int( operand2 )

            #print( "mov: data = ", data )
            
            if operand1 in registers.keys():
                registers[ operand1 ] = data
                #print( "mov: setting", operand1, "to", data )
            elif operand1.find( "ebp+" )!=-1:
                operand1 = operand1.replace( "]", "" )
                offset = int( operand1.split( "ebp+")[1] )
                stack[ registers["ebp"] + offset//4 ] = data
            return False
        
        # dec
        if instruction == "dec":
            if operand1 in registers.keys():
                registers[operand1] -= 1
            else:
                print( "*** Error *** trying to decrement", operand1 )
            return False

        # mul
        if instruction == "mul":
            if operand1 in registers.keys():
                registers["eax"] = registers[operand1] * registers["eax"]
                registers["edx"] = 0
            return False
                 
        # cmp
        if instruction == "cmp":
            if operand2 in registers.keys():
                data = int( registers[operand2] )
            elif operand2.find( "ebp+" )!=-1:
                operand2 = operand2.replace( "]", "" )
                offset = int( operand2.split( "ebp+" )[1] )
                data = stack[ registers["ebp"] + offset//4 ]
                if type(data)==type("string"):
                    data = int( data.split()[0].strip() )

            else:
                data = int( operand2 )
                            
            if operand1 in registers.keys():
                #print( "cmp: operand1 = ", operand1, "value = ",
                #       registers[ operand1 ] )
                flags["l"]  = registers[ operand1 ] < data
                flags["le"] = registers[ operand1 ] <= data
                flags["e"]  = registers[ operand1 ] == data
                flags["ne"] = registers[ operand1 ] != data
                flags["g"]  = registers[ operand1 ] > data
                flags["ge"] = registers[ operand1 ] >= data
            elif operand1.find( "ebp+" )!=-1:
                operand1 = operand1.replace( "]", "" )
                offset = int( operand1.split( "ebp+")[1] )
                operand1 = stack[ registers["ebp"] + offset//4 ]
                if type(operand1)==type("string"):
                    operand1 = int( operand1.split()[0].strip() )

                #print( "cmp: operand1 = ", operand1 )
                flags["l"]  = operand1 < data
                flags["le"] = operand1 <= data
                flags["e"]  = operand1 == data
                flags["ne"] = operand1 != data
                flags["g"]  = operand1 > data
                flags["ge"] = operand1 >= data

            print( "cmp: flags = ", flags )
            return False

        # jg
        if instruction == "jg":
            if flags["g"]:
                self.ip = self.labelAddress[ operand1 ]
                return True
            return False
        
        # ret?
        if instruction == "ret":
            self.ip = self.pop()

            # get the number after ret
            if operand1 != None:
                operand1 = int( operand1 )
                for i in range( 0, operand1, 4 ):
                    self.pop()
            return True
        
        return False

