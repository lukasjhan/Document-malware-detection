import re
import struct
from io import BytesIO
from itertools import islice

import olefile, zlib
from tags import tag_table, control_char_table

class Record(object):
    def __init__(self, tag_id, payload, parent=None):
        self.parent = parent
        self.children = []

        self.tag_id = tag_id
        self.tag_name = tag_table.get(self.tag_id, '<ROOT>')
        self.payload = payload

    def __repr__(self):
        return '<Record %s>' % self.tag_name

    def get_next_siblings(self, count=None):
        start_idx = self.parent.children.index(self) + 1
        if count is None:
            end_idx = None
        else:
            end_idx = start_idx + count

        return islice(self.parent.children, start_idx, end_idx)

    # hwp parse
    @staticmethod
    def build_tree_from_stream(stream):
        root = Record(None, None)

        while True:
            header = stream.read(4)
            if not header:
                break

            header = struct.unpack('<I', header)[0]

            tag_id = header & 0x3ff
            level = (header >> 10) & 0x3ff
            size = (header >> 20) & 0xfff

            if size == 0xfff:
                size = struct.unpack('<I', stream.read(4))[0]

            payload = stream.read(size)

            last_record = root
            for _ in range(level):
                last_record = last_record.children[-1]

            last_record.children.append(Record(tag_id, payload, last_record))

        return root

    def get_text(self):
        regex = re.compile(rb'([\x00-\x1f])\x00')

        text = ''

        cursor_idx = 0
        search_idx = 0

        while cursor_idx < len(self.payload):
            if search_idx < cursor_idx:
                search_idx = cursor_idx

            searched = regex.search(self.payload, search_idx)
            if searched:
                pos = searched.start()

                if pos & 1:
                    search_idx = pos + 1
                elif pos > cursor_idx:
                    text += self.payload[cursor_idx:pos].decode('utf-16')
                    cursor_idx = pos
                else:
                    control_char = ord(searched.group(1))
                    control_char_size = control_char_table[control_char][1].size

                    if control_char == 0x0a:
                        text += '\n'

                    cursor_idx = pos + control_char_size * 2
            else:
                text += self.payload[search_idx:].decode('utf-16')
                break

        return text

class HwpStream(object):
    def __init__(self, stream):
        self.buffer = stream

    def read(self, size):
        result = self.buffer[:size]
        self.buffer = self.buffer[size:]

        return result